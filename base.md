# ðŸ—ï¸ MASTER BLUEPRINT: Cofounder (AI Codebase Orchestrator)

## 1. System Overview & Philosophy

**Cofounder** is an advanced, human-in-the-loop AI codebase planner and orchestrator. It solves the "vibe coding" problem by enforcing a strict **Design-First, Code-Second** pipeline.

The system operates on a continuous feedback loop:

1. **Idea & Negotiation:** An Inquisitive LLM interrogates the user's idea to lock down technical constraints.
2. **Architecture:** The LLM generates a strict contract of Mermaid.js diagrams (Component, ERD, Sequence).
3. **Execution:** The Aider coding agent is programmatically restricted to building exactly what is in the diagrams, operating inside a disposable Docker sandbox.
4. **Evaluation:** Test logs and Aider's architectural friction (Scout Reports) are fed back to the Design LLM for redesign or approval.
5. **Deployment:** Only when the sandbox build is 100% green does the system push the code securely to the user's repository via GitHub OAuth.

---

## 2. The Tech Stack

### Frontend: Next.js (React)

- **Framework:** Next.js (App Router). If you've handled component lifecycles and offline state in React Native applications, translating that mental model to Next.js for the web will feel seamless.
- **Authentication:** NextAuth.js configured strictly for GitHub OAuth (requesting `repo` permissions to allow commits).
- **Real-time:** Native WebSocket API to consume streams from the backend.
- **Visuals:** `mermaid` or `react-mermaid2` for dynamic graph rendering.

### Backend: FastAPI (Python)

- **Framework:** FastAPI running on Uvicorn. The `asyncio` loop will manage multiple non-blocking tasks. Handling concurrent tasks here uses the same principles of multithreading and WebSocket management required for high-frequency trading bots, just applied to AI orchestration.
- **Agent Control:** Aider's Python API (`from aider.coders import Coder`) wrapped in `concurrent.futures.ThreadPoolExecutor` to prevent blocking the async event loop.
- **Execution Environment:** Docker SDK for Python (`docker` package) to spin up ephemeral containers.
- **Version Control:** `GitPython` to manage the authenticated handoff to GitHub.

---

## 3. Frontend Architecture (The Orchestrator Dashboard)

The UI is a three-pane dashboard that updates dynamically via WebSocket events.

### Pane 1: The Chat (Left)

- **Role:** The human-in-the-loop terminal.
- **Behavior:** Parses the backend LLM Markdown. Renders structured "Decision Cards" (Option A vs. Option B) for architectural choices instead of raw text.

### Pane 2: The Canvas (Center)

- **Role:** The Mermaid.js rendering zone.
- **Behavior:** Contains three tabs (Flowchart, ERD, Sequence). Renders the graph dynamically as the WebSocket streams the `graph_update` event. Displays a "Diff" view (red/green nodes) during a redesign cycle.

### Pane 3: The Reality Engine (Right)

- **Role:** Execution tracking and log abstraction.
- **Behavior:** Displays a topological progress stepper (1. DB Models -> 2. Core Logic -> 3. API -> 4. Tests). Only displays standard terminal outputs if the user clicks "Expand Logs."

---

## 4. Backend Orchestration Flow

### Phase A: The Inquisitive Cofounder

1. **System Prompt:** The Design LLM must ask a maximum of 2 high-impact architectural questions per interaction. It must format decisions using the strict `### ðŸŽ¯ Decision Required:` Markdown structure.
2. **The Commit Trigger:** Once constraints are agreed upon, the LLM calls the `finalize_architecture()` tool.
3. **Generation:** The backend prompts the LLM to output three strict ```mermaid blocks: `graph TD`, `erDiagram`, and `sequenceDiagram`.
4. **Validation:** The backend runs a regex or headless parser to ensure the Mermaid syntax is valid before saving it to `TARGET_ARCHITECTURE.md`.

### Phase B: Sandboxed Execution (Aider)

1. **Context Locking:** Aider is initialized with `TARGET_ARCHITECTURE.md` as a **read-only** file. It is explicitly instructed not to hallucinate services outside this graph.
2. **Topological Sorting:** Applying standard tree traversal concepts (like the graph logic required in COMP 2140), the backend parses the Mermaid dependencies and feeds instructions to Aider in chunks: _Models first, then Controllers, then UI._
3. **The Sandbox:** \* Backend creates a disposable Docker container using the Python Docker SDK.

- The generated codebase directory is mounted as a volume.
- Aider executes its generated test suite (e.g., `pytest`) inside the container.

### Phase C: The Feedback Loop (The Scout Report)

1. **Data Capture:** The backend captures the container's exit code, the last 20 lines of `stderr`, and checks for a `SCOUT_REPORT.json` generated by Aider.
2. **The Payload:** The backend structures a JSON payload containing `orchestrator_metadata`, `scout_report`, `execution_logs`, and the specific `architectural_context` node that failed.
3. **Routing:** \* _Bug:_ If `scout_report` is empty, the LLM auto-prompts Aider to fix the bug and reruns the container.

- _Blocker:_ If Aider logged architectural friction, execution halts. The Design LLM parses the payload and sends a pivot proposal to the user in Pane 1.

### Phase D: Secure Deployment

1. **Auth Retrieval:** When the loop resolves green, the Next.js frontend sends the user's active GitHub OAuth Access Token to the backend.
2. **Git Handoff:** The FastAPI backend uses `GitPython` to inject the OAuth token into the remote URL.
3. **The Push:** The backend commits the codebase (and the `ARCHITECTURE.md` file) and pushes directly to the user's GitHub repository.

---

## 5. WebSocket Event Dictionary

The backend and frontend must communicate strictly using this event envelope:
`{"event_type": "string", "timestamp": "ISO8601", "payload": {}}`

- `graph_update`: Streams Mermaid syntax to Pane 2.
- `execution_progress`: Updates the topological stepper in Pane 3.
- `test_result`: Delivers sandbox exit codes and abstracted logs.
- `scout_alert`: Pushes architectural blockers directly to the Chat (Pane 1).
- `deployment_success`: Confirms the GitHub push and completes the loop.
